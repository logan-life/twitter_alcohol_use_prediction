# -*- coding: utf-8 -*-
"""twitter_alcohol_use_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ATgoVwKCtXYbQ7Rv04WBfRlQfQjQYFGS

# Can Twitter be used to predict US county-level excessive alcohol consumption rates? 
### A replication and exploration

[Logan Ayliffe](mailto:lmayliffe@gmail.com),  Audrey Yang,  Joshua Gardos

# Part 0: Boring Imports + Setup

A couple notes before we begin.

Firstly, this notebook relies on a few files for data, and assumes that you have uploaded these to your google drive account already. If you wish to run this locally, change the path code accordingly.

Secondly, this project was initially completed for graduate school at University of Pennsylvania. As such, there may be references to "project scope" and whatnot. I (Logan Ayliffe) have updated it for readability and ease of use, but the odd reference may remain.
"""
import geopandas
from google.colab import drive
import math
from matplotlib import cm
import matplotlib.pyplot as plt
import matplotlib
import pandas as pd
import numpy as np
import sklearn
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import Ridge
from sklearn.pipeline import Pipeline
from sklearn.metrics import mean_squared_error, mean_absolute_error, make_scorer
from scipy import stats
from sklearn.feature_selection import VarianceThreshold
from sklearn.feature_selection import SelectFwe, chi2, f_regression
from sklearn.decomposition import PCA, LatentDirichletAllocation
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import GridSearchCV
from sklearn import random_projection, datasets, cluster
from sklearn.cluster import AgglomerativeClustering
from scipy.cluster.hierarchy import dendrogram
import shutil
import torch
import torchvision
import torch.nn as nn
from torch.autograd import Variable
import torch.nn.functional as F
import torch.utils.data as Data
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")

# This notebook relies on the data being in google drive -- feel free to change to suit your needs.
drive.mount('/content/drive')

"""# Part 1: Data Collection and Wrangling

## Drinking Data
The Behavioral Risk Factor Surveillance System (BRFSS) is a population-based cross-sectional telephone and cell phone health survey of U.S. adults, aged ≥18 years, conducted by state and territorial health departments in conjunction with the Centers for Disease Control and Prevention. 

From the [BRFSS](https://www.cdc.gov/brfss/brfssprevalence/) (2006–2012), we use the county-level prevalence of self-reported binge drinking and heavy drinking. The full dataset is [available here.](https://osf.io/ty2jx/) 

Excessive alcohol consumption was defined as having drunk more than two drinks per day on average (for men) or more than one drink per day on average (for women) or having drunk 5 or more drinks during a single occasion (for men) or 4 or more drinks during a single occasion (for women).
"""

path = "/content/drive/MyDrive/twitter_alcohol_use_prediction/data"

# Read in raw file
drinking_demographics_df = pd.read_csv(path + "/outcomes.csv", index_col=0)

# rename columns for readability (DLATK original version has prescriptive column name formats)
drinking_demographics_df.columns = ['ExcessDrink_Percent', 'FemalePop', 'HispanicPop', 'BlackPop', 'ForeignBornPop', 'hsgrad',
                                    'bachdeg', 'logincome', 'unemploy', 'married', 'age_1_14', 'age_15_29', 'age_30_60', 'age_61_up', 'avg_HSgrad_loginc']
drinking_demographics_df.head()

"""## Demographic and Socioeconomic Data 

We use percentages of female, foreign born, African-American and Hispanic as well as age percentages (19 bins) from the U.S. Census Bureau. County-level measures of log income, percentage of married residents, high school and college graduation rates, and unemployment were obtained from the American Community Survey. Because income and education are highly correlated, we also use a composite county-level socioeconomic index by averaging standardized log income and standardized high school graduation rates. Such averaging often results in a stronger single predictor. *(Citation: Gelman A, Hill J. Data Analysis Using Regression and Multilevel/Hierarchical Models. Cambridge: Cambridge University Press; 2006.)*

The socioeconomic data is bundled with the drinking data in the outcomes.csv file. Again, the full dataset is [available here.](https://osf.io/ty2jx/) 

In line with the original authors, we split the Demographic and Socioeconomic data into four feature sets: 
1. Demographic features only: percentage of female, African American, Hispanic, foreign born and married residents as well as four age bins: 1–14, 15–29, 30–60 and 60+
2. Socioeconomic features only: log income, high school and college graduation rates, and unemployment
3. Single composite socioeconomic index: log income + HS grad rate
4. All of the above combined: all demographic, socioeconomic, and the composite index.
"""

# Split socio-demographic features into 4 sets as described above
demographic_only_features = drinking_demographics_df[['FemalePop', 'HispanicPop', 'BlackPop',
                                                      'ForeignBornPop', 'married', 'age_1_14', 'age_15_29', 'age_30_60', 'age_61_up']].astype('float64')
socioeconomic_index_single_predictor = drinking_demographics_df[[
    'avg_HSgrad_loginc']].astype('float64')
socioeconomic_only_features = drinking_demographics_df[[
    'logincome', 'hsgrad', 'bachdeg', 'unemploy']].astype('float64')
sociodemographic_features = drinking_demographics_df.loc[:,
                                                         drinking_demographics_df.columns != 'ExcessDrink_Percent'].astype('float64')

# grab labels for the above 4 sets
labels = drinking_demographics_df[['ExcessDrink_Percent']].astype('float64')

# show top 10 rows of each socioeconomic / demographic feature set
print("DEMOGRAPHIC FEATURES: \n", demographic_only_features.head(10), "\n\n\n")

print("SOCIOECONOMIC FEATURES: \n",
      socioeconomic_only_features.head(10), "\n\n\n")

print("SINGLE COMPOSITE SOCIOECONOMIC INDEX FEATURE: \n",
      socioeconomic_index_single_predictor.head(10), "\n\n\n")

print("COMBINED SOCIOECONOMIC AND DEMOGRAPHIC FEATURES: \n",
      sociodemographic_features.head(10), "\n\n\n")

"""## Twitter Data

The linguistic features are derived from a large corpus of tweets collected by Curtis et al.

The original paper  collected a random 1% of twitter data between 10/2011 and 12/2013.

These tweets were then geolocated using latlong and self-reported location information in the user's profile. Of the original set of 2.24 billion tweets, 138 million were mapped to counties.

**However, in conversation with one of the authors Salvatore Giorgio, we learned that the group has since collected and validated a better set of county level Twitter lexical data. Here we use this updated dataset.** 

**This data set is derived from a 10% Twitter sample from 2009-2015, and uses  over 1.5 billion tweets that were successfully mapped to counties.**

The Twitter data from the original paper is [here](https://osf.io/zct2b/), and the updated data can be found [here](https://github.com/wwbp/county_tweet_lexical_bank).

### Twitter Data - Feature Extraction
Feature extraction, already performed on the above data and included with the datasets, was done as follows (Citation https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0194290):

1. Tweets are tokenized using a publicly available tokenizer which was designed to capture typical language as well as other social media content such as emoticons (e.g. “:)”, “<3”) and hashtags (e.g. “#weed”) as “words”.

2. Word frequencies were then summed at the county-level and used to find the relative frequencies of groups of related words, known as “topics." Specifically, social media-based set of 2000 topics derived from the MyPersonality Facebook data set (approximately 15 million posts).

3. The topics were automatically discovered using Latent Dirichlet Allocation (LDA), a probabilistic technique. This technique uses a generative model which assumes that each document (in this case, Facebook message) contains a distribution of topics, which is in turn assumed to be a distribution of words. 
The end result of LDA is a set of topics, with weights for each word belonging to the topics, denoted as p(topic|word). Words that are weighted highly within the same topic are those which have appeared in similar contexts.
The particular set of 2000 topics which we use here were derived previously over social media  using the Mallet software package which estimates the latent variable of the topic using Gibbs sampling. When running Mallet, all hyperparameters were set to their default value except alpha, a prior on the expected topics per document, was set to 3. This was chosen under the assumption that Facebook messages contain fewer topics than standard documents, such as blog posts or newspaper articles, where LDA was originally applied. These topics have previously been applied successfully in capturing county life satisfaction and heart disease mortality from tweets.

4. The probability of topic usage per county, P(topic|document), was derived using the equation ![topicmodel.png](data:image/png;base64,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1zpC2r/OdYqqE4LXWPxx8C9jviTLN70gXf4o+MXOhgVPmwaymTdtzeJvMsr49XfOHb1hdbO30NihCPD1SrRy0ngK4Ca19D2m/BVb+21JcbrlN9x/d6l8IQnJLdKF0pVvXQwp0oXw5cX+qa50dVd5+ZFYqnc5fQ7J2rvJDetb0FWVPlmpl7d6oa95k/b/K1ohwddLGnjnX3te4+56xF4L9TAcmBqRQB3xvXK/rgUgmUp836Q+g4QXwBTAPySqMRLq2QjucUjByZZCPUVY5M8VVu/jF0CPdPx6qCudSlpKlgEO+XUP/WlHVVBIiHs43xp5+2gCrEeSvqjn+8b0eWR3KHMAiRr7n7f01ULQ+WX7zFAl8PXCXZBNqC1xaWAjXVqfVozDsLeW0MA1CquUez3Fcbj/8VYm5bSoweN5TQ3AcSwwr0x1aX1q4cH5vx7tTjsk0R0/a/1X+689gO3ud760BAt7XQhd6cq3If8DopNub0Zsii4AAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMDMtMTBUMDU6MzU6NDItMDg6MDCFFv5SAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTAzLTEwVDA1OjM1OjQyLTA4OjAw9EtG7gAAABR0RVh0ZGM6Zm9ybWF0AGltYWdlL3RpZmYkez/DAAAAGHRFWHRleGlmOlBpeGVsWERpbWVuc2lvbgAzODCNbx4LAAAAF3RFWHRleGlmOlBpeGVsWURpbWVuc2lvbgAzNyVQSh0AAAAVdEVYdHBob3Rvc2hvcDpDb2xvck1vZGUAM1YCs0AAAAAmdEVYdHBob3Rvc2hvcDpJQ0NQcm9maWxlAHNSR0IgSUVDNjE5NjYtMi4xHC9sCwAAAA90RVh0dGlmZjplbmRpYW4AbHNiVbcXQwAAABR0RVh0dGlmZjpwaG90b21ldHJpYwBSR0KzIEnfAAAAFnRFWHR0aWZmOnJvd3MtcGVyLXN0cmlwADM37STV5AAAACp0RVh0dGlmZjpzb2Z0d2FyZQBBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3Mplb4omwAAACJ0RVh0dGlmZjp0aW1lc3RhbXAAMjAxODowMzoxMCAxOTowMzoxNRPjocYAAAAodEVYdHhtcDpDcmVhdGVEYXRlADIwMTgtMDMtMTBUMTc6MjY6MjcrMDU6MzAAjEraAAAAKnRFWHR4bXA6TWV0YWRhdGFEYXRlADIwMTgtMDMtMTBUMTk6MDM6MTUrMDU6MzDVZU2iAAAAKHRFWHR4bXA6TW9kaWZ5RGF0ZQAyMDE4LTAzLTEwVDE5OjAzOjE1KzA1OjMw6cEeHAAAAEt0RVh0eG1wTU06RG9jdW1lbnRJRABhZG9iZTpkb2NpZDpwaG90b3Nob3A6YWNkNzIwOWQtMDg1YS1hODQ4LWFiNTUtNGRmNWMwMzBiZmFhTgUE5QAAAD10RVh0eG1wTU06SW5zdGFuY2VJRAB4bXAuaWlkOjhhMmVjMTVhLTM2NmUtYmE0MC1iYTcxLWI1ZTYwM2ZlODk0M0YMaU8AAABFdEVYdHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRAB4bXAuZGlkOmQyOTM0MWUyLTliNTEtNDA0ZS1hODJiLTZhYzFjNGM5YmQ0NvsIqw4AAAAASUVORK5CYII=),
where document represents a county in this case. Here P(tok|document) was estimated from the relative frequency of tokens (words) in the county (as described above) and P(topic|tok), the probability of a topic given the token, was derived though the LDA process. Thus, for each county, scores for the 2000 pre-specified topics formed the independent variables. The topic scores for each county as well as the topics themselves have been open-sourced and are available at at [www.wwbp.org/data.html](www.wwbp.org/data.html).

Note that the field group_normX reflects the group norm of topic X, while valueX represents the value of topic X.
"""

# read in the raw file
linguistic_features_raw_df = pd.read_csv(
    path + "/linguistic_features.csv", index_col=0)

# group_id 0 is an aggregate and not an actual county, do not need it
linguistic_features_raw_df = linguistic_features_raw_df[linguistic_features_raw_df.group_id != 0]

"""### Understanding the raw data 
The columns here reflect the county code (group_id), the id of the topic identified during feature extraction, the raw value of topic frequency usage in that county and finally the group_norm for that topic relative to usage of other topics within that group. It is this last that we will train our model on.
"""

print("\n\n\nRAW LINGUISTIC FEATURES : \n",
      linguistic_features_raw_df.head(10), "\n\n\n")

"""### Transforming the raw data
Next we manipulate this dataframe to index by county and set the group_norm values for each topic feature as a column. The upshot of this is that we will end up with on average 2000 features per county.
"""

# transpose and reindex the data, rename column for readability, and join with our labels df on 'county' (group_id).
linguistic_features_df = pd.pivot_table(linguistic_features_raw_df, values=[
                                        'feat', 'value', 'group_norm'], index='group_id', columns='feat')
linguistic_features_df.reset_index(inplace=True)
columns = ['County'] + ['feat_'+str(i) + '_group_norm' for i in range(2000)] + [
    'value_'+str(i) for i in range(2000)]
linguistic_features_df.columns = columns
linguistic_features_df = linguistic_features_df.join(
    labels, on='County', how='inner')

# At this point we still have the raw values columns (2000 of them) for each topic per county, and we only use group norms, so we can drop those:

# temporarily store the label column
linguistic_labels = linguistic_features_df['ExcessDrink_Percent']
# remove the values columns by slicing
linguistic_features_df = linguistic_features_df.iloc[:, : 2001]
# rejoin the labels
linguistic_features_df['ExcessDrink_Percent'] = linguistic_labels
print("LINGUISTIC FEATURES MASTER DF: \n", linguistic_features_df.head(10))

"""### Two strategies for handling missing twitter data

Not every county has the full 2000 topic features computed using the tokenized Twitter data. To handle missing data, we experiment with two strategies: value imputation, replacing all NaNs with 0, and dropping the null rows entirely.

As you can see below, with value imputation we retain all 1,604 counties. With dropna, we end up with 1,488 counties, we lose about 7% of the counties if we drop nulls. 

"""

# Strategy 1 - impute 0
linguistic_features_impute = linguistic_features_df.fillna(0)

# Strategy 2 - dropna
linguistic_features_dropna = linguistic_features_df.dropna()

# Now get the separate label sets for each (separate because now the shapes are different)
linguistic_labels_impute = linguistic_features_impute[['ExcessDrink_Percent']]
linguistic_labels_dropna = linguistic_features_dropna[['ExcessDrink_Percent']]

# remove the labels column from both of the feature sets and reindex
linguistic_features_impute.set_index('County', inplace=True)
linguistic_features_dropna.set_index('County', inplace=True)
linguistic_features_impute = linguistic_features_impute.loc[:,
                                                            linguistic_features_impute.columns != 'ExcessDrink_Percent'].astype('float64')
linguistic_features_dropna = linguistic_features_dropna.loc[:,
                                                            linguistic_features_dropna.columns != 'ExcessDrink_Percent'].astype('float64')


print('impute current shape: ', linguistic_features_impute.shape,
      '\n\ndropna current shape: ', linguistic_features_dropna.shape, "\n\n")
print("LINGUISTIC FEATURES IMPUTE: \n", linguistic_features_impute.head(
    10), "\n\nLINGUISTIC FEATURES DROPNA: \n", linguistic_features_dropna.head(10))

# Setting aside this for later
combined_df_impute = linguistic_features_impute
combined_df_dropna = linguistic_features_dropna

"""# Part 2: Preparing to build our models
Before we can build the models, we need to process the data a bit. For our twitter data, we have more features (2000 topics weighted by group norm per county) than we do units of analysis (1,604 counties and 1,488 counties using the two different missing data strategies).

Given this, we follow Curtis et al. in their pipeline design for this training data for removing low variance features.

## Feature selection
"""

# feature selection per original paper
scaler = MinMaxScaler()
linguistic_features_impute = scaler.fit_transform(linguistic_features_impute)
linguistic_features_dropna = scaler.fit_transform(linguistic_features_dropna)
# step 1: remove low variance features
linguistic_features_impute = VarianceThreshold(
).fit_transform(linguistic_features_impute)
linguistic_features_dropna = VarianceThreshold(
).fit_transform(linguistic_features_dropna)
# step 2: remove uncorrelated features with family-wise error rate alpha of 60
linguistic_features_impute = SelectFwe(score_func=f_regression, alpha=60).fit_transform(
    linguistic_features_impute, linguistic_labels_impute)
linguistic_features_dropna = SelectFwe(score_func=f_regression, alpha=60).fit_transform(
    linguistic_features_dropna, linguistic_labels_dropna)

"""## Splitting the data into Train / Val / Test

While the author's used 10 fold cross-validation, we split into Train / Val / Test per the project assignment. We need will need seven total sets of data for training:
0. Twitter language only - impute
1. Twitter language only - dropna
2. Demographics only
3. Socioeconomics only
4. Composite socioeconomic single predictor
5. Demographics + Socioeconomics
6. The best performing Twitter language model + Demographics + Socioeconomics
"""

# helper function - splits a feature and label set into 3 subsets of Train, Val, and Test, 80/10/10


def train_test_val_split(features, labels):
    X_train, X_test, y_train, y_test = train_test_split(
        features, labels, test_size=0.1, random_state=1)
    X_train, X_val, y_train, y_val = train_test_split(
        X_train, y_train, test_size=0.11, random_state=1)

    return X_train, X_val, X_test, y_train, y_val, y_test


# set 0 - Twitter language only - IMPUTE
X_IMPUTE_train, X_IMPUTE_val, X_IMPUTE_test, y_IMPUTE_train, y_IMPUTE_val, y_IMPUTE_test = train_test_val_split(
    linguistic_features_impute, linguistic_labels_impute)

# set 1 - Twitter language only - DROPNA
X_DROPNA_train, X_DROPNA_val, X_DROPNA_test, y_DROPNA_train, y_DROPNA_val, y_DROPNA_test = train_test_val_split(
    linguistic_features_dropna, linguistic_labels_dropna)

# set 2 - Demographics only
X_DEMO_train, X_DEMO_val, X_DEMO_test, y_DEMO_train, y_DEMO_val, y_DEMO_test = train_test_val_split(
    demographic_only_features, labels)

# set 3 - Socioeconomics only
X_SOCIO_train, X_SOCIO_val, X_SOCIO_test, y_SOCIO_train, y_SOCIO_val, y_SOCIO_test = train_test_val_split(
    socioeconomic_only_features, labels)

# set 4 - Composite socioeconomic single predictor
X_SOCIOCOMPOSITE_train, X_SOCIOCOMPOSITE_val, X_SOCIOCOMPOSITE_test, y_SOCIOCOMPOSITE_train, y_SOCIOCOMPOSITE_val, y_SOCIOCOMPOSITE_test = train_test_val_split(
    socioeconomic_index_single_predictor, labels)

# set 5 - Demographics + Socioeconomics
X_SOCIODEMO_train, X_SOCIODEMO_val, X_SOCIODEMO_test, y_SOCIODEMO_train, y_SOCIODEMO_val, y_SOCIODEMO_test = train_test_val_split(
    sociodemographic_features, labels)

"""Per the project spec, the size of each set of training / validation / testing data is printed below. """

# set 0 - Twitter language only - IMPUTE
print('Linguistic impute training features shape: ', X_IMPUTE_train.shape)
print('Linguistic impute validation features shape: ', X_IMPUTE_val.shape)
print('Linguistic impute testing features shape: ', X_IMPUTE_test.shape, '\n')

# set 1 - Twitter language only - DROPNA
print('Linguistic dropna training features shape: ', X_DROPNA_train.shape)
print('Linguistic dropna validation features shape: ', X_DROPNA_val.shape)
print('Linguistic dropna testing features shape: ', X_DROPNA_test.shape, '\n')

# set 2 - Demographics only
print('Demographics training features shape: ', X_DEMO_train.shape)
print('Demographics validation features shape: ', X_DEMO_val.shape)
print('Demographics testing features shape: ', X_DEMO_test.shape, '\n')

# set 3 - Socioeconomics only
print('Socioeconomics training features shape: ', X_SOCIO_train.shape)
print('Socioeconomics validation features shape: ', X_SOCIO_val.shape)
print('Socioeconomics testing features shape: ', X_SOCIO_test.shape, '\n')

# set 4 - Composite socioeconomic single predictor
print('Socioeconomic Single Index training features shape: ',
      X_SOCIOCOMPOSITE_train.shape)
print('Socioeconomic Single Index validation features shape: ',
      X_SOCIOCOMPOSITE_val.shape)
print('Socioeconomic Single Index testing features shape: ',
      X_SOCIOCOMPOSITE_test.shape, '\n')

# set 5 - Demographics + Socioeconomics
print('Demographics + Socioeconomics training features shape: ',
      X_SOCIODEMO_train.shape)
print('Demographics + Socioeconomics validation features shape: ',
      X_SOCIODEMO_val.shape)
print('Demographics + Socioeconomics testing features shape: ',
      X_SOCIODEMO_test.shape, '\n')

"""# Part 3: Training Our Models

## Simple Linear Regression Models + Demographic & Socioeconomic Features
We first train four simple linear regression models on the four different permutations of demographic and socioeconomic features
"""

# DEMO ONLY MODEL
reg_demo = LinearRegression().fit(X_DEMO_train, y_DEMO_train)
y_demo_pred = reg_demo.predict(X_DEMO_val)

# SOCIO ONLY
reg_all_socio = LinearRegression().fit(X_SOCIO_train, y_SOCIO_train)
y_all_socio_pred = reg_all_socio.predict(X_SOCIO_val)

# SOCIOECONOMIC COMPOSITE SINGLE PREDICTOR
reg_single_socio = LinearRegression().fit(
    X_SOCIOCOMPOSITE_train, y_SOCIOCOMPOSITE_train)
y_single_socio_pred = reg_single_socio.predict(X_SOCIOCOMPOSITE_val)

#DEMOGRAPHICS + SOCIOECONOMICS
reg_sociodemo = LinearRegression().fit(X_SOCIODEMO_train, y_SOCIODEMO_train)
y_sociodemo_pred = reg_sociodemo.predict(X_SOCIODEMO_val)

"""## PCA + Ridge Regression Model + Twitter Language Features
For each of our Twitter feature strategies, we first fit PCA onto our training data, then transform our training / validation / test data.

Then we train a ridge regression model on our transformed data.
"""

# fit PCA on the training data only
pca_impute = PCA(.95)
pca_impute.fit(X_IMPUTE_train)

pca_dropna = PCA(.95)
pca_dropna.fit(X_DROPNA_train)

# apply PCA transform to both training, validation, and test data
X_IMPUTE_train_transformed = pca_impute.transform(X_IMPUTE_train)
X_IMPUTE_val_transformed = pca_impute.transform(X_IMPUTE_val)
X_IMPUTE_test_transformed = pca_impute.transform(X_IMPUTE_test)

X_DROPNA_train_transformed = pca_dropna.transform(X_DROPNA_train)
X_DROPNA_val_transformed = pca_dropna.transform(X_DROPNA_val)
X_DROPNA_test_transformed = pca_dropna.transform(X_DROPNA_test)

print('\n\n\nIMPUTE FINAL SHAPE: \n', X_IMPUTE_train.shape,
      '\nDROPNA FINAL SHAPE: \n', X_DROPNA_train.shape, "\n")

ridge_impute = Ridge().fit(X_IMPUTE_train_transformed, y_IMPUTE_train)
ridge_dropna = Ridge().fit(X_DROPNA_train_transformed, y_DROPNA_train)

"""## Combined data

We combined the all the data seen. This is done by regress the sociodemographic data against drinking data first, then using the residuals as the feature column to combine with twitter features.

Running PCA produces only 1 component, so we will not use the combined data in our extensions.
"""

sociodemographic_features_dropna = sociodemographic_features.loc[combined_df_dropna.index]

combined_df_impute['residual'] = reg_sociodemo.predict(
    sociodemographic_features)
combined_df_dropna['residual'] = reg_sociodemo.predict(
    sociodemographic_features_dropna)

# feature selection per original paper
scaler = MinMaxScaler()
combined_df_impute = scaler.fit_transform(combined_df_impute)
combined_df_dropna = scaler.fit_transform(combined_df_dropna)
# step 1: remove low variance features
combined_df_impute = VarianceThreshold().fit_transform(combined_df_impute)
combined_df_dropna = VarianceThreshold().fit_transform(combined_df_dropna)
# step 2: remove uncorrelated features with family-wise error rate alpha of 60
combined_df_impute = SelectFwe(score_func=f_regression, alpha=60).fit_transform(
    combined_df_impute, linguistic_labels_impute)
combined_df_dropna = SelectFwe(score_func=f_regression, alpha=60).fit_transform(
    combined_df_dropna, linguistic_labels_dropna)

X_COMBINED_DROPNA_train, X_COMBINED_DROPNA_val, X_COMBINED_DROPNA_test, y_COMBINED_DROPNA_train, y_COMBINED_DROPNA_val, y_COMBINED_DROPNA_test = train_test_val_split(
    combined_df_dropna, linguistic_labels_dropna)
X_COMBINED_IMPUTE_train, X_COMBINED_IMPUTE_val, X_COMBINED_IMPUTE_test, y_COMBINED_IMPUTE_train, y_COMBINED_IMPUTE_val, y_COMBINED_IMPUTE_test = train_test_val_split(
    combined_df_impute, linguistic_labels_impute)

# PCA variance graph
pca = PCA(n_components=1471)
pca.fit(combined_df_impute)
var = pca.explained_variance_ratio_

var_num = np.cumsum(pca.explained_variance_ratio_)
fig, ax = plt.subplots(figsize=(8, 6))
plt.plot(var_num)

# fit PCA on the training data only
pca_combined_impute = PCA(0.95)
pca_combined_impute.fit(X_COMBINED_IMPUTE_train)

pca_combined_dropna = PCA(0.95)
pca_combined_dropna.fit(X_COMBINED_DROPNA_train)

# apply PCA transform to both training, validation, and test data
X_COMBINED_IMPUTE_train_transformed = pca_combined_impute.transform(
    X_COMBINED_IMPUTE_train)
X_COMBINED_IMPUTE_val_transformed = pca_combined_impute.transform(
    X_COMBINED_IMPUTE_val)
X_COMBINED_IMPUTE_test_transformed = pca_combined_impute.transform(
    X_COMBINED_IMPUTE_test)

X_COMBINED_DROPNA_train_transformed = pca_combined_dropna.transform(
    X_COMBINED_DROPNA_train)
X_COMBINED_DROPNA_val_transformed = pca_combined_dropna.transform(
    X_COMBINED_DROPNA_val)
X_COMBINED_DROPNA_test_transformed = pca_combined_dropna.transform(
    X_COMBINED_DROPNA_test)

print('\n\n\nIMPUTE FINAL SHAPE: \n', X_COMBINED_IMPUTE_train_transformed.shape,
      '\nDROPNA FINAL SHAPE: \n', X_COMBINED_DROPNA_train_transformed.shape, "\n")

ridge_combined_impute = Ridge().fit(
    X_COMBINED_IMPUTE_train_transformed, y_IMPUTE_train)
ridge_combined_dropna = Ridge().fit(
    X_COMBINED_DROPNA_train_transformed, y_DROPNA_train)

"""# Part 4: Evaluating Our Models

## How do we quantify model performance? 
In general, we will quantify the effectiveness of a model in the same way that Curtis et al do: through reporting Pearson r and Mean Absolute Error. Their results are showng in the figure below.

![originalresults.png](data:image/png;base64,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aW5hbERvY3VtZW50SUQAdXVpZDpCNzIzNzg4Ny03MzkwLUUxNTAtMEYyOC1DOUEyOUVEMkFDNTV3UpVXAAAAD3RFWHR0aWZmOmVuZGlhbgBsc2JVtxdDAAAAFHRFWHR0aWZmOnBob3RvbWV0cmljAFJHQrMgSd8AAAAWdEVYdHRpZmY6cm93cy1wZXItc3RyaXAANTVVcBNOAAAAKnRFWHR0aWZmOnNvZnR3YXJlAEFkb2JlIFBob3Rvc2hvcCBDQyAoV2luZG93cymVviibAAAAInRFWHR0aWZmOnRpbWVzdGFtcAAyMDE4OjAzOjEwIDE5OjAzOjAwepJkCAAAACh0RVh0eG1wOkNyZWF0ZURhdGUAMjAxOC0wMy0xMFQxNzoyNTo0OSswNTozMH3rgwMAAABKdEVYdHhtcDpDcmVhdG9yVG9vbABBcmJvcnRleHQgQWR2YW5jZWQgUHJpbnQgUHVibGlzaGVyIDExLjAuMjg1Ny9XIFVuaWNvZGUteDY0z3DqDAAAACd0RVh0eG1wOk1ldGFkYXRhRGF0ZQAyMDE4LTAzLTEwVDE5OjAzKzA1OjMwSIKDCgAAACV0RVh0eG1wOk1vZGlmeURhdGUAMjAxOC0wMy0xMFQxOTowMyswNTozMGHRkO8AAAA6dEVYdHhtcE1NOkRvY3VtZW50SUQAdXVpZDpCNzIzNzg4Ny03MzkwLUUxNTAtMEYyOC1DOUEyOUVEMkFDNTXfIqWgAAAAPXRFWHR4bXBNTTpJbnN0YW5jZUlEAHhtcC5paWQ6NjMzZjZhNzgtMDAxOS1hYTQ0LThlZDktOTcyMjk0Y2ViMTYwy6ZlhwAAAEJ0RVh0eG1wTU06T3JpZ2luYWxEb2N1bWVudElEAHV1aWQ6QjcyMzc4ODctNzM5MC1FMTUwLTBGMjgtQzlBMjlFRDJBQzU1RO+dMgAAAABJRU5ErkJggg==)

Our evaluation script takes as input a list of gold labels and a list of predicted values, outputting the Pearson r correlation and mean absolute error. These are the metrics used by the original authors.
"""


def evaluate(y_val, y_pred, model_name):
    correlation, p_value = stats.pearsonr(
        y_pred.flatten(), y_val.ExcessDrink_Percent.astype('float64'))
    print("Evaluation results for ", model_name.upper())
    print('Pearson R: ', correlation, '\nMean Absolute Error: ',
          mean_absolute_error(y_val, y_pred), '\nP-value: ', p_value, '\n\n')


"""## What is our baseline?
We go a step beyond random values for establishing our baseline. Instead, we follow Curtis et al in using the various demographic and socioeconomic feature trained models as our control baseline. 

These data are already known to correlate with drinking, so the idea here is to see if we can beat the correlational strength by using Twitter language alone or in combination with sociodemographic controls.

## Evaluating our baseline
We expect that our baseline models should be in line with Curtis et al. We report our results below.
"""

# Compute predictions for baseline models
y_demo_pred = reg_demo.predict(X_DEMO_val)
y_all_socio_pred = reg_all_socio.predict(X_SOCIO_val)
y_single_socio_pred = reg_single_socio.predict(X_SOCIOCOMPOSITE_val)
y_sociodemo_pred = reg_sociodemo.predict(X_SOCIODEMO_val)

baseline_preds = {"demo_only": (y_demo_pred, y_DEMO_val), "single_socio": (y_single_socio_pred, y_SOCIOCOMPOSITE_val), "all_socio": (
    y_all_socio_pred, y_SOCIO_val), "all_socio_demo": (y_sociodemo_pred, y_SOCIODEMO_val)}

# evaluate baseline predictions
for label, prediction in baseline_preds.items():
    evaluate(prediction[1], prediction[0], label)

"""As you can see, our results are very close to the authors results. We suspect that the small amount of delta likely results from our using Train / Val / Test splits on this data compared with the authors' use of cross-fold validation.

## Evaluating our Twitter models on the validation set

We expect that our Twitter models should perform about as well. We do anticipate some amount of difference as our model is using the updated county-mapping logic in the twitter dataset, as described in Section 1: Data Collection and Wrangling.
"""

# Compute predictions for twitter models
y_IMPUTE_pred = ridge_impute.predict(X_IMPUTE_val_transformed)
y_DROPNA_pred = ridge_dropna.predict(X_DROPNA_val_transformed)

twitter_preds = {"ling_only_impute": (
    y_IMPUTE_pred, y_IMPUTE_val), "ling_only_dropna": (y_DROPNA_pred, y_DROPNA_val)}

# evaluate twitter model predictions
for label, prediction in twitter_preds.items():
    evaluate(prediction[1], prediction[0], label)

# Compute predictions for combined
y_COMBINED_IMPUTE_pred = ridge_combined_impute.predict(
    X_COMBINED_IMPUTE_val_transformed)
y_COMBINED_DROPNA_pred = ridge_combined_dropna.predict(
    X_COMBINED_DROPNA_val_transformed)

combined_preds = {"combined_impute": (y_COMBINED_IMPUTE_pred, y_COMBINED_IMPUTE_val), "combined_dropna": (
    y_COMBINED_DROPNA_pred, y_COMBINED_DROPNA_val)}

# Evaluate combined model predictions
for label, prediction in combined_preds.items():
    evaluate(prediction[1], prediction[0], label)

"""# Part 5: Extensions

## Extension 1: Different Methods of Dimensionality Reduction

The original paper used PCA for dimensionality reduction in the Twitter data. We now experiment with other methods for the same set of data – the lower variance filter, random projection, feature agglomeration, and LDA. These methods were implemented using functions from `scikit-learn`.

All methods were run on both the dropped and imputed data, and we continued to use a Ridge regression model with parameter 1000 as our predictor. We compare the results to the results given by PCA.

### Low Variance + Family-Wise Error Rate Filter

We already use a low variance filter (`VarianceThreshold`) along with a family-wise error rate filter (`SelectFwe`) before getting the train-test splits.

For this method, we replace PCA with another round of filtering out low variances and high family-wise error rates. We first use a GridSearch to get the optimal threshold and family-wise error rate and use the GridSearched values to apply to the data.

**Note - this next cell can take a while to run!**
"""

# GridSearch
pipe = Pipeline([
    ('variance_threshold', VarianceThreshold()),
    ('select_fwe', SelectFwe(score_func=f_regression)),
    ('ridge', Ridge(alpha=1000))
])

threshold_guesses = [0, 0.05, 0.15, 0.25, 0.35, 0.5,
                     0.65, 0.75, 0.85, 1, 1.5] + list(range(2, 50))
alpha_guesses = list(range(1, 2000, 25))

params = [
    {
        'variance_threshold__threshold': threshold_guesses,
        'select_fwe__alpha': alpha_guesses
    }
]

GS_impute = GridSearchCV(pipe, param_grid=params, n_jobs=-1,
                         scoring='neg_mean_absolute_error', refit=True)
GS_impute.fit(X_IMPUTE_train, y_IMPUTE_train)

print('Best estimator:', GS_impute.best_estimator_)
print('Best parameters:', GS_impute.best_params_)
print('Best score:', GS_impute.best_score_)

GS_dropna = GridSearchCV(pipe, param_grid=params, n_jobs=-1,
                         scoring='neg_mean_absolute_error', refit=True)
GS_dropna.fit(X_DROPNA_train, y_DROPNA_train)

print('Best estimator:', GS_dropna.best_estimator_)
print('Best parameters:', GS_dropna.best_params_)
print('Best score:', GS_dropna.best_score_)

# IMPUTE
# Remove low variance features
var_threshold_impute = VarianceThreshold(threshold=GS_impute.best_params_[
                                         'variance_threshold__threshold']).fit(X_IMPUTE_train)
X_IMPUTE_train_transformed = var_threshold_impute.transform(X_IMPUTE_train)
X_IMPUTE_val_transformed = var_threshold_impute.transform(X_IMPUTE_val)

# Remove uncorrelated features with family-wise error rate alpha of 390
select_fwe_impute = SelectFwe(score_func=f_regression, alpha=GS_impute.best_params_[
                              'select_fwe__alpha']).fit(X_IMPUTE_train_transformed, y_IMPUTE_train)
X_IMPUTE_train_transformed = select_fwe_impute.transform(
    X_IMPUTE_train_transformed)
X_IMPUTE_val_transformed = select_fwe_impute.transform(
    X_IMPUTE_val_transformed)

print('\n\n\nIMPUTE FINAL SHAPE: \n', X_IMPUTE_train_transformed.shape)

# DROPNA
# Remove low variance features
var_threshold_dropna = VarianceThreshold(threshold=GS_dropna.best_params_[
                                         'variance_threshold__threshold']).fit(X_DROPNA_train)
X_DROPNA_train_transformed = var_threshold_dropna.transform(X_DROPNA_train)
X_DROPNA_val_transformed = var_threshold_dropna.transform(X_DROPNA_val)

# Remove uncorrelated features with family-wise error rate alpha of 390
select_fwe_dropna = SelectFwe(score_func=f_regression, alpha=GS_dropna.best_params_[
                              'select_fwe__alpha']).fit(X_DROPNA_train_transformed, y_DROPNA_train)
X_DROPNA_train_transformed = select_fwe_dropna.transform(
    X_DROPNA_train_transformed)
X_DROPNA_val_transformed = select_fwe_dropna.transform(
    X_DROPNA_val_transformed)

print('\nDROPNA FINAL SHAPE: \n', X_DROPNA_train_transformed.shape)

# Fit ridge models
ridge_impute = Ridge(alpha=1000).fit(
    X_IMPUTE_train_transformed, y_IMPUTE_train)
ridge_dropna = Ridge(alpha=1000).fit(
    X_DROPNA_train_transformed, y_DROPNA_train)

# Compute predictions for twitter models
y_IMPUTE_pred = ridge_impute.predict(X_IMPUTE_val_transformed)
y_DROPNA_pred = ridge_dropna.predict(X_DROPNA_val_transformed)

twitter_preds = {"ling_only_impute": (
    y_IMPUTE_pred, y_IMPUTE_val), "ling_only_dropna": (y_DROPNA_pred, y_DROPNA_val)}

# Evaluate twitter model predictions
for label, prediction in twitter_preds.items():
    evaluate(prediction[1], prediction[0], label)

"""We see here that another round of using `VarianceThreshold` and `SelectFwe` does not make a difference to the data, since the dimensions remain the same exactly the same. This makes intuitive sense for the low variance filter because our threshold continues to be the default 0. However, for the family-wise error filter, we get a different optimal value that does not change the data. 

Hence, we conclude that this method is worse than PCA.

### Random Projection

Random projections are a simple and efficient way to reduce dimensionality. It trades a controlled amount of accuracy (as an additional variance) for a faster processing time and a smaller model size.

`scikit-learn.random_projection` contains two such methods. We chose to use `GaussianRandomProjection` because it ran better than the `SparseRandomProjection` (our data also is not very sparse). 

`scikit-learn` uses the Johnson-Lindenstrauss lemma to give an estimate of the minimal size of the random subspace to guarantee a bounded distortion from the random projection. However, when we tried to get an automatic discovery of the number of components, the estimate was too conservative (it actually was more than our original number). So, we used GridSearch instead to tune the number of components.
"""

# GridSearch
pipe = Pipeline([
    ('random_projection', random_projection.GaussianRandomProjection()),
    ('ridge', Ridge(alpha=1000))
])

component_guesses = list(range(1, 300))

params = [
    {'random_projection__n_components': component_guesses}
]

GS_impute = GridSearchCV(pipe, param_grid=params, n_jobs=-1,
                         scoring='neg_mean_absolute_error', refit=True)
GS_impute.fit(X_IMPUTE_train, y_IMPUTE_train)

print('Best estimator:', GS_impute.best_estimator_)
print('Best parameters:', GS_impute.best_params_)
print('Best score:', GS_impute.best_score_)

GS_dropna = GridSearchCV(pipe, param_grid=params, n_jobs=-1,
                         scoring='neg_mean_absolute_error', refit=True)
GS_dropna.fit(X_DROPNA_train, y_DROPNA_train)

print('Best estimator:', GS_dropna.best_estimator_)
print('Best parameters:', GS_dropna.best_params_)
print('Best score:', GS_dropna.best_score_)

transformer_impute = random_projection.GaussianRandomProjection(
    n_components=GS_impute.best_params_['random_projection__n_components'])
transformer_dropna = random_projection.GaussianRandomProjection(
    n_components=GS_dropna.best_params_['random_projection__n_components'])

# Fit to training data
transformer_impute.fit(X_IMPUTE_train)
transformer_dropna.fit(X_DROPNA_train)

# apply PCA transform to both training, validation, and test data
X_IMPUTE_train_transformed = transformer_impute.transform(X_IMPUTE_train)
X_IMPUTE_val_transformed = transformer_impute.transform(X_IMPUTE_val)
X_IMPUTE_test_transformed = transformer_impute.transform(X_IMPUTE_test)

X_DROPNA_train_transformed = transformer_dropna.transform(X_DROPNA_train)
X_DROPNA_val_transformed = transformer_dropna.transform(X_DROPNA_val)
X_DROPNA_test_transformed = transformer_dropna.transform(X_DROPNA_test)

print('IMPUTE FINAL SHAPE: \n', X_IMPUTE_train_transformed.shape,
      '\nDROPNA FINAL SHAPE: \n', X_DROPNA_train_transformed.shape, "\n")

# Fit a ridge model
ridge_impute = Ridge(alpha=1000).fit(
    X_IMPUTE_train_transformed, y_IMPUTE_train)
ridge_dropna = Ridge(alpha=1000).fit(
    X_DROPNA_train_transformed, y_DROPNA_train)

# Compute predictions for twitter models
y_IMPUTE_pred = ridge_impute.predict(X_IMPUTE_val_transformed)
y_DROPNA_pred = ridge_dropna.predict(X_DROPNA_val_transformed)

twitter_preds = {"ling_only_impute": (
    y_IMPUTE_pred, y_IMPUTE_val), "ling_only_dropna": (y_DROPNA_pred, y_DROPNA_val)}

# evaluate twitter model predictions
for label, prediction in twitter_preds.items():
    evaluate(prediction[1], prediction[0], label)

"""Random projection produced less components than PCA did in both cases, since both were less than 200. The regression model performed worse using the transformed data from random projections.

### Feature Agglomeration

`scikit-learn`'s Feature Agglomeration uses hierarchichal clustering to group features that behave similarly. 

We use two methods to determine the number of clusters – finding a good distance threshold and a GridSearch.

#### Distance Thresholding

We first plot a dendrogram, which shows the number of clusters for each dissimilarity. Our threshold will be at the lowest level of clusters.
"""

# Dendrogram plot code (from sklearn docs)


def plot_dendrogram(model, **kwargs):
    counts = np.zeros(model.children_.shape[0])
    n_samples = len(model.labels_)
    for i, merge in enumerate(model.children_):
        current_count = 0
        for child_idx in merge:
            if child_idx < n_samples:
                current_count += 1  # leaf node
            else:
                current_count += counts[child_idx - n_samples]
        counts[i] = current_count

    linkage_matrix = np.column_stack([model.children_, model.distances_,
                                      counts]).astype(float)

    # Plot the corresponding dendrogram
    dendrogram(linkage_matrix, **kwargs)


# IMPUTE Dendrogram
model = AgglomerativeClustering(distance_threshold=0, n_clusters=None)

model = model.fit(X_IMPUTE_train)
plt.title('Hierarchical Clustering Dendrogram for IMPUTE')
# plot the top three levels of the dendrogram
plot_dendrogram(model, truncate_mode='level', p=3)
plt.xlabel("Number of points in node (or index of point if no parenthesis).")
plt.ylabel("Distance")
plt.show()

# DROPNA Dendrogram
model = AgglomerativeClustering(distance_threshold=0, n_clusters=None)

model = model.fit(X_DROPNA_train)
plt.title('Hierarchical Clustering Dendrogram for DROPNA')
# plot the top three levels of the dendrogram
plot_dendrogram(model, truncate_mode='level', p=3)
plt.xlabel("Number of points in node (or index of point if no parenthesis).")
plt.ylabel("Distance")
plt.show()

agglo_impute = cluster.FeatureAgglomeration(
    n_clusters=None, distance_threshold=8)
agglo_dropna = cluster.FeatureAgglomeration(
    n_clusters=None, distance_threshold=5)

# Fit to training data
agglo_impute.fit(X_IMPUTE_train)
agglo_dropna.fit(X_DROPNA_train)

# apply PCA transform to both training, validation, and test data
X_IMPUTE_train_transformed = agglo_impute.transform(X_IMPUTE_train)
X_IMPUTE_val_transformed = agglo_impute.transform(X_IMPUTE_val)
X_IMPUTE_test_transformed = agglo_impute.transform(X_IMPUTE_test)

X_DROPNA_train_transformed = agglo_dropna.transform(X_DROPNA_train)
X_DROPNA_val_transformed = agglo_dropna.transform(X_DROPNA_val)
X_DROPNA_test_transformed = agglo_dropna.transform(X_DROPNA_test)

print('IMPUTE FINAL SHAPE: \n', X_IMPUTE_train_transformed.shape,
      '\nDROPNA FINAL SHAPE: \n', X_DROPNA_train_transformed.shape, "\n")

# Fit a ridge model
ridge_impute = Ridge(alpha=1000).fit(
    X_IMPUTE_train_transformed, y_IMPUTE_train)
ridge_dropna = Ridge(alpha=1000).fit(
    X_DROPNA_train_transformed, y_DROPNA_train)

# Compute predictions for twitter models
y_IMPUTE_pred = ridge_impute.predict(X_IMPUTE_val_transformed)
y_DROPNA_pred = ridge_dropna.predict(X_DROPNA_val_transformed)

twitter_preds = {"ling_only_impute": (
    y_IMPUTE_pred, y_IMPUTE_val), "ling_only_dropna": (y_DROPNA_pred, y_DROPNA_val)}

# Evaluate twitter model predictions
for label, prediction in twitter_preds.items():
    evaluate(prediction[1], prediction[0], label)

"""#### GridSearch

As in the previous methods, we use a GridSearch to find the optimal number of clusters.
"""

# GridSearch
pipe = Pipeline([
    ('agglomeration', cluster.FeatureAgglomeration()),
    ('ridge', Ridge(alpha=1000))
])

cluster_guesses = list(range(1, 1000, 4))

params = [
    {'agglomeration__n_clusters': cluster_guesses}
]

GS_impute = GridSearchCV(pipe, param_grid=params, n_jobs=-1,
                         scoring='neg_mean_absolute_error', refit=True)
GS_impute.fit(X_IMPUTE_train, y_IMPUTE_train)

print('Best estimator:', GS_impute.best_estimator_)
print('Best parameters:', GS_impute.best_params_)
print('Best score:', GS_impute.best_score_)

GS_dropna = GridSearchCV(pipe, param_grid=params, n_jobs=-1,
                         scoring='neg_mean_absolute_error', refit=True)
GS_dropna.fit(X_DROPNA_train, y_DROPNA_train)

print('Best estimator:', GS_dropna.best_estimator_)
print('Best parameters:', GS_dropna.best_params_)
print('Best score:', GS_dropna.best_score_)

agglo_impute = cluster.FeatureAgglomeration(
    n_clusters=GS_impute.best_params_['agglomeration__n_clusters'])
agglo_dropna = cluster.FeatureAgglomeration(
    n_clusters=GS_dropna.best_params_['agglomeration__n_clusters'])

# Fit to training data
agglo_impute.fit(X_IMPUTE_train)
agglo_dropna.fit(X_DROPNA_train)

# apply PCA transform to both training, validation, and test data
X_IMPUTE_train_transformed = agglo_impute.transform(X_IMPUTE_train)
X_IMPUTE_val_transformed = agglo_impute.transform(X_IMPUTE_val)
X_IMPUTE_test_transformed = agglo_impute.transform(X_IMPUTE_test)

X_DROPNA_train_transformed = agglo_dropna.transform(X_DROPNA_train)
X_DROPNA_val_transformed = agglo_dropna.transform(X_DROPNA_val)
X_DROPNA_test_transformed = agglo_dropna.transform(X_DROPNA_test)

print('IMPUTE FINAL SHAPE: \n', X_IMPUTE_train_transformed.shape,
      '\nDROPNA FINAL SHAPE: \n', X_DROPNA_train_transformed.shape, "\n")

# Fit a ridge model
ridge_impute = Ridge(alpha=1000).fit(
    X_IMPUTE_train_transformed, y_IMPUTE_train)
ridge_dropna = Ridge(alpha=1000).fit(
    X_DROPNA_train_transformed, y_DROPNA_train)

# Compute predictions for twitter models
y_IMPUTE_pred = ridge_impute.predict(X_IMPUTE_val_transformed)
y_DROPNA_pred = ridge_dropna.predict(X_DROPNA_val_transformed)

twitter_preds = {"ling_only_impute": (
    y_IMPUTE_pred, y_IMPUTE_val), "ling_only_dropna": (y_DROPNA_pred, y_DROPNA_val)}

# evaluate twitter model predictions
for label, prediction in twitter_preds.items():
    evaluate(prediction[1], prediction[0], label)

"""With distance thresholding, Feature Agglomeration produced less components than PCA did. It also performed far worse. 

With the GridSearched cluster number, Feature Agglomeration produced more components than PCA did. This method also did not work as well as PCA.

### Latent Dirichlet Allocation (LDA)

LDA is a method is usually used for topic modeling. In fact, it was used to obtain the topics from Facebook that was a part of our Twitter data. We use it on our data to group our features into a certain number of components.

To run GridSearch for the optimal number of components is very time-intensive with LDA. To perform the manual search, uncomment the next cell. This will take a long time.
"""

# GridSearch (LEAVE THIS COMMENTED AND USE HARD-CODED VALUES IN NEXT CELL TO SAVE TIME)
# pipe = Pipeline([
#     ('lda', LatentDirichletAllocation()),
#     ('ridge', Ridge(alpha=1000))
# ])

# component_guesses = [50, 100, 200]

# params = [
#   {'lda__n_components': component_guesses}
# ]

# GS_impute = GridSearchCV(pipe, param_grid=params, n_jobs=-1, scoring='neg_mean_absolute_error', refit=True)
# GS_impute.fit(X_IMPUTE_train, y_IMPUTE_train)

# print('Best estimator:', GS_impute.best_estimator_)
# print('Best parameters:', GS_impute.best_params_)
# print('Best score:', GS_impute.best_score_)
# # GridSearch (SKIP THIS CELL AND UNCOMMENT HARD-CODED VALUES TO SAVE TIME)
# component_guesses = [50, 100, 200]
# params = [
#   {'lda__n_components': component_guesses}
# ]

# GS_dropna = GridSearchCV(pipe, param_grid=params, n_jobs=-1, scoring='neg_mean_absolute_error', refit=True)
# GS_dropna.fit(X_DROPNA_train, y_DROPNA_train)

# print('Best estimator:', GS_dropna.best_estimator_)
# print('Best parameters:', GS_dropna.best_params_)
# print('Best score:', GS_dropna.best_score_)


# lda_impute = LatentDirichletAllocation(n_components=GS_impute.best_params_['lda__n_components'])
# lda_dropna = LatentDirichletAllocation(n_components=GS_dropna.best_params_['lda__n_components'])

lda_impute = LatentDirichletAllocation(100)
lda_dropna = LatentDirichletAllocation(50)

# Fit to training data
lda_impute.fit(X_IMPUTE_train)
lda_dropna.fit(X_DROPNA_train)

# Apply PCA transform to both training, validation, and test data
X_IMPUTE_train_transformed = lda_impute.transform(X_IMPUTE_train)
X_IMPUTE_val_transformed = lda_impute.transform(X_IMPUTE_val)
X_IMPUTE_test_transformed = lda_impute.transform(X_IMPUTE_test)

X_DROPNA_train_transformed = lda_dropna.transform(X_DROPNA_train)
X_DROPNA_val_transformed = lda_dropna.transform(X_DROPNA_val)
X_DROPNA_test_transformed = lda_dropna.transform(X_DROPNA_test)

print('IMPUTE FINAL SHAPE: \n', X_IMPUTE_train_transformed.shape,
      '\nDROPNA FINAL SHAPE: \n', X_DROPNA_train_transformed.shape, '\n')

# Fit a ridge model
ridge_impute = Ridge(alpha=1000).fit(
    X_IMPUTE_train_transformed, y_IMPUTE_train)
ridge_dropna = Ridge(alpha=1000).fit(
    X_DROPNA_train_transformed, y_DROPNA_train)

# Compute predictions for twitter models
y_IMPUTE_pred = ridge_impute.predict(X_IMPUTE_val_transformed)
y_DROPNA_pred = ridge_dropna.predict(X_DROPNA_val_transformed)

twitter_preds = {"ling_only_impute": (
    y_IMPUTE_pred, y_IMPUTE_val), "ling_only_dropna": (y_DROPNA_pred, y_DROPNA_val)}

# evaluate twitter model predictions
for label, prediction in twitter_preds.items():
    evaluate(prediction[1], prediction[0], label)

"""LDA took a particularly long time to run. Due to the time contraints of the project and the constraints of the available technology, we could not tune LDA more. In the future, this could be a good method for dimensionality reduction, given more computing power. But for now, the small search space yielded a number of components for which LDA did not perform better than PCA.

After these experiments, we conclude that PCA is the best method for dimensionality reduction for our data.

## Extension 2: Neural Network

In our second extension, we train a neural network instead of using the Ridge Regression model in our baseline. This is done to hopefully capture some of the underlying complexities from the data.

As in our baseline model, we continue to use PCA.

### PCA

After the last experiment, we reset our transformed data.
"""

# Apply PCA transform to both training, validation, and test data
X_IMPUTE_train_transformed = pca_impute.transform(X_IMPUTE_train)
X_IMPUTE_val_transformed = pca_impute.transform(X_IMPUTE_val)

X_DROPNA_train_transformed = pca_dropna.transform(X_DROPNA_train)
X_DROPNA_val_transformed = pca_dropna.transform(X_DROPNA_val)

"""### Model Definition

After tuning (the results of which are listed in our paper), we found that a neural network with one hidden layer and a sigmoid activation and no dropout worked the best. We define this below using PyTorch's `nn.Sequential`.
"""

# General method to get a neural net with specific dimensions


def fnn(input_dim, hidden1, output_dim):
    fnn = nn.Sequential(
        nn.Linear(input_dim, hidden1),
        nn.Sigmoid(),
        nn.Linear(hidden1, output_dim)
    )
    return fnn


# Neural nets for each dataset
fnn_impute = fnn(374, 187, 1)
fnn_dropna = fnn(350, 175, 1)

"""### Training

Our training function takes in the training data and labels and converts them into tensors. We then create a DataLoader with batch size of 16 (chosen over the other tested options of 8, 32, and 64). The method then trains the model over a certain number of epochs, iterating through the dataloader object each time.
"""


def train_model(model, optimizer, criterion, data, labels, epochs=10):
    dataset = Data.TensorDataset(torch.Tensor(data), torch.Tensor(labels))
    loader = Data.DataLoader(
        dataset=dataset,
        batch_size=16,
        shuffle=True, num_workers=2,)

    losses, accuracies = [], []
    for i in range(epochs):
        for X, y in loader:
            preds = model(X)

            loss = criterion(preds, y)

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

        losses.append(loss.item())

    final_training_loss = sum(losses) / len(losses)
    return final_training_loss, losses


"""Our chosen optimizer is Adam, and we optimize with the mean squared error loss function. Though our results are reported as a mean absolute error, the training loss with that function did not converge.

The loss seems to converge sometime to 150 every time, so we train each model for 150 epochs.
"""

# IMPUTE
impute_optimizer = torch.optim.Adam(fnn_impute.parameters(), lr=1e-4)
criterion = torch.nn.MSELoss()

final_training_loss, losses = train_model(
    fnn_impute, impute_optimizer, criterion,
    X_IMPUTE_train_transformed, y_IMPUTE_train.values,
    150)

final_training_loss

# Plot loss
plt.plot([i for i in range(1, 151)], losses)
plt.title('IMPUTE Loss per Epoch'),
plt.xlabel('Epoch number')
plt.ylabel('Loss')
plt.show()

# DROPNA
dropna_optimizer = torch.optim.Adam(fnn_dropna.parameters(), lr=1e-4)
criterion = torch.nn.MSELoss()

final_training_loss, losses = train_model(
    fnn_dropna, dropna_optimizer, criterion,
    X_DROPNA_train_transformed, y_DROPNA_train.values,
    150)

final_training_loss

# Plot loss
plt.plot([i for i in range(1, 151)], losses)
plt.title('DROPNA Loss per Epoch'),
plt.xlabel('Epoch number')
plt.ylabel('Loss')
plt.show()

"""### Testing

We test our model here on the validation set and report the Pearson r and mean absolute error (`L1Loss` from PyTorch).
"""


def test_model(model, criterion, data, labels):
    with torch.no_grad():
        X, y = torch.Tensor(data), torch.Tensor(labels)
        model.eval()

        preds = model(X)
        loss = criterion(preds, y)
        r = stats.pearsonr(labels.flatten(), preds.numpy().flatten())
        testing_loss = loss.item()
        return testing_loss, r[0]


# IMPUTE
testing_loss_impute, pearson_r_impute = test_model(
    fnn_impute, torch.nn.L1Loss(), X_IMPUTE_val_transformed, y_IMPUTE_val.values)
print('RESULTS FOR IMPUTE NN:')
print('MAE:', testing_loss_impute)
print('Pearson R:', pearson_r_impute)

# DROPNA
testing_loss_dropna, pearson_r_dropna = test_model(
    fnn_dropna, torch.nn.L1Loss(), X_DROPNA_val_transformed, y_DROPNA_val.values)
print('RESULTS FOR DROPNA NN:')
print('MAE:', testing_loss_dropna)
print('Pearson R:', pearson_r_dropna)

"""We see that the neural network offers a slightly improved error rate over the ridge regression model.

# Part 6: Final Results

## Evaluation on Test Set

### Published Baseline Results

We now run our published baseline on the test set.
"""

# Apply PCA transform to both training, validation, and test data
X_IMPUTE_train_transformed = pca_impute.transform(X_IMPUTE_train)
X_IMPUTE_val_transformed = pca_impute.transform(X_IMPUTE_val)
X_IMPUTE_test_transformed = pca_impute.transform(X_IMPUTE_test)

X_DROPNA_train_transformed = pca_dropna.transform(X_DROPNA_train)
X_DROPNA_val_transformed = pca_dropna.transform(X_DROPNA_val)
X_DROPNA_test_transformed = pca_dropna.transform(X_DROPNA_test)

# Fitting a ridge model
ridge_impute = Ridge().fit(X_IMPUTE_train_transformed, y_IMPUTE_train)
ridge_dropna = Ridge().fit(X_DROPNA_train_transformed, y_DROPNA_train)

# Compute predictions for twitter models
y_IMPUTE_pred = ridge_impute.predict(X_IMPUTE_test_transformed)
y_DROPNA_pred = ridge_dropna.predict(X_DROPNA_test_transformed)

twitter_preds = {"ling_only_impute": (
    y_IMPUTE_pred, y_IMPUTE_test), "ling_only_dropna": (y_DROPNA_pred, y_DROPNA_test)}

# Evaluate twitter model predictions
for label, prediction in twitter_preds.items():
    evaluate(prediction[1], prediction[0], label)

"""We also run the model on the combined data."""

# Compute predictions for combined
y_COMBINED_IMPUTE_pred = ridge_combined_impute.predict(
    X_COMBINED_IMPUTE_test_transformed)
y_COMBINED_DROPNA_pred = ridge_combined_dropna.predict(
    X_COMBINED_DROPNA_test_transformed)

combined_preds = {"combined_impute": (y_COMBINED_IMPUTE_pred, y_COMBINED_IMPUTE_test), "combined_dropna": (
    y_COMBINED_DROPNA_pred, y_COMBINED_DROPNA_test)}

# Evaluate combined model predictions
for label, prediction in combined_preds.items():
    evaluate(prediction[1], prediction[0], label)

"""### Extension Results

We choose our best performing extension, which is the feed-forward neural network with one hidden layer and a sigmoid activation and no dropout. We use Adam as the optimizer and MSE as our loss function.
"""

# IMPUTE
fnn_impute = fnn(374, 187, 1)
impute_optimizer = torch.optim.Adam(fnn_impute.parameters(), lr=1e-4)
criterion = torch.nn.MSELoss()

final_training_loss, losses = train_model(
    fnn_impute, impute_optimizer, criterion,
    X_IMPUTE_train_transformed, y_IMPUTE_train.values,
    150)

testing_loss_impute, pearson_r_impute = test_model(
    fnn_impute, torch.nn.L1Loss(), X_IMPUTE_test_transformed, y_IMPUTE_test.values)
print('NN IMPUTE TEST RESULTS')
print('MAE:', testing_loss_impute)
print('Pearson R:', pearson_r_impute)

# DROPNA
fnn_dropna = fnn(350, 175, 1)
dropna_optimizer = torch.optim.Adam(fnn_dropna.parameters(), lr=1e-4)
criterion = torch.nn.MSELoss()

final_training_loss, losses = train_model(
    fnn_dropna, dropna_optimizer, criterion,
    X_DROPNA_train_transformed, y_DROPNA_train.values,
    150)

testing_loss_dropna, pearson_r_dropna = test_model(
    fnn_dropna, torch.nn.L1Loss(), X_DROPNA_test_transformed, y_DROPNA_test.values)
print('NN DROPNA TEST RESULTS')
print('MAE:', testing_loss_dropna)
print('Pearson R:', pearson_r_dropna)

# IMPUTE COMBINED
fnn_impute_combined = fnn(374, 187, 1)
impute_combined_optimizer = torch.optim.Adam(
    fnn_impute_combined.parameters(), lr=1e-4)
criterion = torch.nn.MSELoss()

final_training_loss, losses = train_model(
    fnn_impute_combined, impute_combined_optimizer, criterion,
    X_COMBINED_IMPUTE_train_transformed, y_COMBINED_IMPUTE_train.values,
    150)

testing_loss_combined_impute, pearson_r_combined_impute = test_model(
    fnn_impute_combined, torch.nn.L1Loss(), X_COMBINED_IMPUTE_test_transformed, y_IMPUTE_test.values)
print('NN IMPUTE COMBINED TEST RESULTS')
print('MAE:', testing_loss_combined_impute)
print('Pearson R:', pearson_r_combined_impute)

# DROPNA COMBINED
fnn_dropna_combined = fnn(350, 175, 1)
dropna_combined_optimizer = torch.optim.Adam(
    fnn_dropna_combined.parameters(), lr=1e-4)
criterion = torch.nn.MSELoss()

final_training_loss, losses = train_model(
    fnn_dropna_combined, dropna_combined_optimizer, criterion,
    X_COMBINED_DROPNA_train_transformed, y_DROPNA_train.values,
    150)

testing_loss_combined_dropna, pearson_r_combined_dropna = test_model(
    fnn_dropna_combined, torch.nn.L1Loss(), X_COMBINED_DROPNA_test_transformed, y_DROPNA_test.values)
print('NN DROPNA TEST RESULTS')
print('MAE:', testing_loss_combined_dropna)
print('Pearson R:', pearson_r_combined_dropna)

"""## Conclusion

We find the neural network runs the best with DROPNA data. If we optimize for Pearson R, the combined data works the best; if we optimize for MAE, the linguistic-only data works the best. Both perform better than the ridge regression model used in the original paper.

 See our paper for [more detailed results.](https://github.com/logan-life/twitter_alcohol_use_prediction)
"""
